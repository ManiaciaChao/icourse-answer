[{"choices":[{"pos":"A","content":"(19，21，5，37，2)","index":0},{"pos":"B","content":"(19，21，5，2，37)","index":1},{"pos":"C","content":"(19，21，2，5，37)","index":2},{"pos":"D","content":"(19，21，37，5，2)","index":3}],"answer":"D","answerContent":"(19，21，37，5，2)","question":"对关键字序列（21,19,37,5,2），经直接插入排序法由小到大排序，第一趟后所得结果为（  ）。","id":0},{"choices":[{"pos":"A","content":"(19，21，37，5，2)","index":4},{"pos":"B","content":"(19，21，2，5，37)","index":5},{"pos":"C","content":"(19，21，5，2，37)","index":6},{"pos":"D","content":"(19，21，5，37，2)","index":7}],"answer":"C","answerContent":"(19，21，5，2，37)","question":"对关键字序列（21,19,37,5,2），经冒泡排序法由小到大排序，第一趟后所得结果为（  ）。","id":1},{"choices":[{"pos":"A","content":"(113，165，176，197，127，138，149)","index":8},{"pos":"B","content":"(113，127，138，149，165，176，197)","index":9},{"pos":"C","content":"(113，165，176，127，197，138，149)","index":10},{"pos":"D","content":"(149，138，165，197，176，113，127)","index":11}],"answer":"A","answerContent":"(113，165，176，197，127，138，149)","question":"对关键字序列（149,138,165,197,176,113,127），采用基数排序的第一趟之后所得结果为（  ）。","id":2},{"choices":[{"pos":"A","content":"(5，23，68，16，94)","index":12},{"pos":"B","content":"(5，16，23，68，94)","index":13},{"pos":"C","content":"(5，23，16，68，94)","index":14},{"pos":"D","content":"(5，23，16，94，68)","index":15}],"answer":"A","answerContent":"(5，23，68，16，94)","question":"下列各项键值（  ）序列不是堆的。","id":3},{"choices":[{"pos":"A","content":"(62，24，36，19)\n\n (19，24，36，62)","index":16},{"pos":"B","content":"(24，62，19，36)\n\n(19，24，36，62)","index":17},{"pos":"C","content":"(24，19，36，62)\n\n(24，19，36，62)\n\n (19，24，36，62)","index":18},{"pos":"D","content":"(24，62，36，19)\n\n(24，36，62，19)\n\n(19，24，36，62)","index":19}],"answer":"B","answerContent":"(24，62，19，36)\n\n(19，24，36，62)","question":"假设一组待排序的关键字序列为（24,62,36,19），要求从小到大进行排序，（  ）是归并排序的过程。","id":4},{"choices":[{"pos":"A","content":"选择排序","index":20},{"pos":"B","content":"快速排序","index":21},{"pos":"C","content":"归并排序","index":22},{"pos":"D","content":"冒泡排序","index":23}],"answer":"C","answerContent":"归并排序","question":"在第一趟排序之后，不能确保将数据表中某一个元素放在其最终位置上的排序算法是（  ）。","id":5},{"choices":[{"pos":"A","content":"归并排序","index":24},{"pos":"B","content":"基数排序","index":25},{"pos":"C","content":"直接插入排序","index":26},{"pos":"D","content":"冒泡排序","index":27}],"answer":"C","answerContent":"直接插入排序","question":"对于下列排序，（  ）的时间效率与关键字初始序列有直接关系。","id":6},{"choices":[{"pos":"A","content":"直接选择排序","index":28},{"pos":"B","content":"冒泡排序","index":29},{"pos":"C","content":"直接插入排序","index":30},{"pos":"D","content":"归并排序","index":31}],"answer":"D","answerContent":"归并排序","question":"对于下列排序，（  ）的最坏时间复杂度是O(n㏒n)。","id":7},{"choices":[{"pos":"A","content":"m","index":32},{"pos":"B","content":"n","index":33},{"pos":"C","content":"min{n,m}","index":34},{"pos":"D","content":"max{n,m}","index":35}],"answer":"C","answerContent":"min{n,m}","question":"假设两个有序表长度分别为n和m，将其归并成一个有序表最少需要（  ）次关键字之间的比较。","id":8},{"choices":[{"pos":"A","content":"直接插入排序","index":36},{"pos":"B","content":"冒泡排序","index":37},{"pos":"C","content":"直接选择排序","index":38},{"pos":"D","content":"归并排序","index":39}],"answer":"D","answerContent":"归并排序","question":"对于下列排序，（  ）需要额外辅助存储空间达到O(n)。","id":9},{"choices":[{"pos":"A","content":"(13,27,38,49,49,65,76,97)","index":40},{"pos":"B","content":"(97,76,65,49,49,13,27,38)","index":41},{"pos":"C","content":"(97,65,76,49,49,13,27,38)","index":42},{"pos":"D","content":"(97,76,65,49,49,38,27,13)","index":43}],"answer":"B","answerContent":"(97,76,65,49,49,13,27,38)","question":".对于关键字序列(49,38,65,97,76,13,27,49)，完成创建的大根堆是（  ）。","id":10},{"choices":[{"pos":"A","content":"插入","index":44},{"pos":"B","content":"冒泡","index":45},{"pos":"C","content":"归并","index":46},{"pos":"D","content":"选择","index":47}],"answer":"D","answerContent":"选择","question":"对关键字序列（30，26，18，16，5，66），进行2遍（  ）排序后得到序列（5，16，18，26，30，66）。","id":11},{"choices":[{"pos":"A","content":"冒泡","index":48},{"pos":"B","content":"快速","index":49},{"pos":"C","content":"堆","index":50},{"pos":"D","content":"插入","index":51}],"answer":"D","answerContent":"插入","question":"在下列排序算法中，（  ）排序算法可能出现如下情况：在最后一趟排序之前，所有元素均不在其最终的位置上。","id":12},{"choices":[{"pos":"A","content":"直接插入","index":52},{"pos":"B","content":"直接选择","index":53},{"pos":"C","content":"冒泡","index":54},{"pos":"D","content":"快速","index":55}],"answer":"D","answerContent":"快速","question":"在下列排序方法中，（  ）排序方法的平均时间复杂度不是O（）.","id":13},{"choices":[{"pos":"A","content":"n+m-2","index":56},{"pos":"B","content":"n+m+1","index":57},{"pos":"C","content":"n+m-1","index":58},{"pos":"D","content":"n+m","index":59}],"answer":"C","answerContent":"n+m-1","question":"假设两个有序表长度分别为n和m，将其归并成一个有序表最多需要（  ）次关键字之间的比较。","id":14},{"choices":[{"pos":"A","content":"堆","index":60},{"pos":"B","content":"冒泡","index":61},{"pos":"C","content":"希尔","index":62},{"pos":"D","content":"快速","index":63}],"answer":"B","answerContent":"冒泡","question":"下列排序算法中，（  ）排序算法是稳定的。","id":15},{"choices":[{"pos":"A","content":"冒泡","index":64},{"pos":"B","content":"插入","index":65},{"pos":"C","content":"归并","index":66},{"pos":"D","content":"简单选择","index":67}],"answer":"C","answerContent":"归并","question":"假设待排序的表长为n，那么下列排序算法中，（  ）排序算法需要O(n)的辅助空间。","id":16},{"choices":[{"pos":"A","content":"O(㏒n)","index":68},{"pos":"B","content":"O(n㏒n)","index":69},{"pos":"C","content":"O(n)","index":70},{"pos":"D","content":"O(1)","index":71}],"answer":"A","answerContent":"O(㏒n)","question":"假设待排序的表长为n，那么快速排序算法需要（  ）的辅助空间。","id":17},{"choices":[{"pos":"A","content":"2-路插入","index":72},{"pos":"B","content":"表插入","index":73},{"pos":"C","content":"折半插入","index":74},{"pos":"D","content":"希尔","index":75}],"answer":"B","answerContent":"表插入","question":"在下列排序算法中，（  ）排序算法可以避免在排序过程中移动数据元素。\n\n\n","id":18},{"choices":[{"pos":"A","content":"O(n㏒n)","index":76},{"pos":"B","content":"O(n)","index":77},{"pos":"C","content":"O(1)","index":78},{"pos":"D","content":"O(㏒n)","index":79}],"answer":"B","answerContent":"O(n)","question":"假设待排序的表长为n，那么创建堆需要时间复杂度为（  ）。","id":19},{"choices":[{"pos":"A","content":"简单插入排序","index":80},{"pos":"B","content":"快速排序","index":81},{"pos":"C","content":"归并排序","index":82},{"pos":"D","content":"堆排序","index":83}],"answer":"B","answerContent":"快速排序","question":"在下列排序算法中，在待排序序列为有序的情况下，（  ）的时间复杂度是O()，其中n为待排序序列的数据元素个数。","id":20},{"choices":[{"pos":"A","content":"直接插入排序","index":84},{"pos":"B","content":"快速排序","index":85},{"pos":"C","content":"堆排序","index":86},{"pos":"D","content":"简单选择排序","index":87}],"answer":"B","answerContent":"快速排序","question":"下列四种排序中，（  ）的辅助空间复杂度是最高的。","id":21},{"choices":[{"pos":"A","content":"3","index":88},{"pos":"B","content":"12","index":89},{"pos":"C","content":"6","index":90},{"pos":"D","content":"9","index":91}],"answer":"B","answerContent":"12","question":"设哈希表为HT[0..16]，哈希函数H(key)=key%13，采用线性探测开放地址法处理冲突，且HT中已有关键字为11、28、47和18这4个数据元素，现插入关键字为24的数据元素，其实际存储的地址是（  ）。","id":22},{"choices":[{"pos":"A","content":"n(n-1)","index":92},{"pos":"B","content":"n","index":93},{"pos":"C","content":"n+1","index":94},{"pos":"D","content":"n-1","index":95}],"answer":"D","answerContent":"n-1","question":"对顺序表中的n个记录进行直接插入排序，在最好情况下需要比较（  ）次关键字。","id":23},{"choices":[{"pos":"A","content":"排序算法的性能和被排序的数据数量关系密切","index":96},{"pos":"B","content":"经过排序后，能使原来关键字值相同的数据保持原有顺序中的绝对位置不变","index":97},{"pos":"C","content":"经过排序后，能使原来关键字值相同的数据保持原有顺序中的相对位置不变","index":98},{"pos":"D","content":"排序算法的性能和被排序的数据数量关系不大","index":99}],"answer":"C","answerContent":"经过排序后，能使原来关键字值相同的数据保持原有顺序中的相对位置不变","question":"排序算法的稳定性是指（  ）。","id":24},{"choices":[{"pos":"A","content":"wrong","index":100},{"pos":"B","content":"correct","index":101}],"answer":"A","answerContent":"wrong","question":"简单插入排序算法是不稳定的。","id":25},{"choices":[{"pos":"A","content":"correct","index":102},{"pos":"B","content":"wrong","index":103}],"answer":"A","answerContent":"correct","question":"待排序记录关键字出现有序的初始排列时，快速排序的时间复杂性达到最坏情况。","id":26},{"choices":[{"pos":"A","content":"correct","index":104},{"pos":"B","content":"wrong","index":105}],"answer":"B","answerContent":"wrong","question":"相对于简单插入排序而言，半插入排序减少了关键字比较和移动的次数。","id":27},{"choices":[{"pos":"A","content":"correct","index":106},{"pos":"B","content":"wrong","index":107}],"answer":"B","answerContent":"wrong","question":"对顺序表中的n个记录进行直接插入排序，在初始关键字序列为逆序的情况下，需要关键字比较的次数最少。","id":28},{"choices":[{"pos":"A","content":"correct","index":108},{"pos":"B","content":"wrong","index":109}],"answer":"A","answerContent":"correct","question":"对顺序表中的n个记录进行简单选择排序，至多需要关键字交换n-1次。","id":29},{"choices":[{"pos":"A","content":"wrong","index":110},{"pos":"B","content":"correct","index":111}],"answer":"B","answerContent":"correct","question":"堆排序是一种选择排序。","id":30},{"choices":[{"pos":"A","content":"wrong","index":112},{"pos":"B","content":"correct","index":113}],"answer":"A","answerContent":"wrong","question":"对长度为8的表，作2路归并排序，关键字之间最多需要21次比较。","id":31},{"choices":[{"pos":"A","content":"correct","index":114},{"pos":"B","content":"wrong","index":115}],"answer":"A","answerContent":"correct","question":"快速排序方法的每一趟都能将一个元素把它放到最终的位置上。","id":32},{"choices":[{"pos":"A","content":"wrong","index":116},{"pos":"B","content":"correct","index":117}],"answer":"A","answerContent":"wrong","question":"因为堆排序的算法时间复杂度为O(n㏒n)，冒泡排序的算法复杂度为O(n2 )，所以堆排序一定比冒泡排序的速度快。","id":33},{"choices":[{"pos":"A","content":"correct","index":118},{"pos":"B","content":"wrong","index":119}],"answer":"A","answerContent":"correct","question":"对有n个记录的表作直接插入排序，在最坏的情况下，需比较关键字的次数为n(n-1)/2。","id":34},{"choices":[{"pos":"A","content":"correct","index":120},{"pos":"B","content":"wrong","index":121}],"answer":"B","answerContent":"wrong","question":"在快速排序、堆排序和归并排序中，快速排序需要的辅助空间最多。","id":35},{"choices":[{"pos":"A","content":"wrong","index":122},{"pos":"B","content":"correct","index":123}],"answer":"B","answerContent":"correct","question":"如果冒泡排序的某趟过程中没有出现数据交换情况，那么说明关键字序列已经有序。","id":36},{"choices":[{"pos":"A","content":"correct","index":124},{"pos":"B","content":"wrong","index":125}],"answer":"B","answerContent":"wrong","question":"排序的稳定性是指排序算法中的比较次数保持不变，且算法能够终止。","id":37},{"choices":[{"pos":"A","content":"wrong","index":126},{"pos":"B","content":"correct","index":127}],"answer":"A","answerContent":"wrong","question":"在初始数据表已经有序时，快速排序算法的时间复杂度为O(n㏒n )。","id":38},{"choices":[{"pos":"A","content":"wrong","index":128},{"pos":"B","content":"correct","index":129}],"answer":"A","answerContent":"wrong","question":"如果关键字序列是堆，则关键字序列对应的二叉树是一棵二叉排序树。","id":39},{"choices":[{"pos":"A","content":"wrong","index":130},{"pos":"B","content":"correct","index":131}],"answer":"B","answerContent":"correct","question":"在用堆排序算法排序时，如果要进行增序排序，则需要采用“大根堆”。","id":40},{"choices":[{"pos":"A","content":"wrong","index":132},{"pos":"B","content":"correct","index":133}],"answer":"A","answerContent":"wrong","question":"在任何情况下，归并排序都比简单插入排序快。","id":41},{"choices":[{"pos":"A","content":"correct","index":134},{"pos":"B","content":"wrong","index":135}],"answer":"B","answerContent":"wrong","question":"排序要求数据一定要以顺序方式存储。","id":42},{"choices":[{"pos":"A","content":"wrong","index":136},{"pos":"B","content":"correct","index":137}],"answer":"B","answerContent":"correct","question":"直接选择排序的比较次数与关键字序列的初始状态无关。","id":43},{"choices":[{"pos":"A","content":"wrong","index":138},{"pos":"B","content":"correct","index":139}],"answer":"A","answerContent":"wrong","question":"因为接插入排序是稳定的，而Shell 排序是调用若干趟直接插入排序，所以也是稳定的。","id":44},{"choices":[{"pos":"A","content":"wrong","index":140},{"pos":"B","content":"correct","index":141}],"answer":"A","answerContent":"wrong","question":"以中序方式遍历一个堆序列对应的二叉树，则得到一个有序序列。","id":45},{"choices":[{"pos":"A","content":"wrong","index":142},{"pos":"B","content":"correct","index":143}],"answer":"B","answerContent":"correct","question":"二路归并排序的核心操作是把两个有序序列合并为一个有序序列。","id":46},{"choices":[{"pos":"A","content":"wrong","index":144},{"pos":"B","content":"correct","index":145}],"answer":"B","answerContent":"correct","question":"如果关键字序列采用单链表存储，那么基数排序过程可以避免大量数据移动。","id":47},{"choices":[{"pos":"A","content":"correct","index":146},{"pos":"B","content":"wrong","index":147}],"answer":"B","answerContent":"wrong","question":"基数排序是一种基于最高位优先(MSD)的多关键字排序法。","id":48},{"choices":[{"pos":"A","content":"correct","index":148},{"pos":"B","content":"wrong","index":149}],"answer":"A","answerContent":"correct","question":"基于“比较”运算的排序算法，其时间复杂度的下界为O(n㏒n)。","id":49}]